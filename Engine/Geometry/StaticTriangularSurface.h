
// The Lithopia project initiated by Jeong-Mo Hong for 3D Printing Community.
// Copyright (c) 2015 Jeong-Mo Hong - All Rights Reserved. 
// This file is subject to the terms and conditions defined in 
// file 'LICENSE.txt', which is part of this source code package.#pragma once

#include <atomic>
#include <openctm.h>
#include <glm/glm.hpp>

#include "BOX_3D.h"
#include "VERTEX_OPERATIONS.h"
#include "StaticTriangle.h"
#include "StaticTriangleOperations.h"
#include "GENERIC_DEFINITIONS.h"
#include "DataStructure/LinkedArray.h"
#include "DataStructure/DynamicArray.h"
#include "DataStructure/Vector3D.h"
#include "Geometry/PLANE.h"

class StaticTriangularSurface
{
public:
	Array1D<TV>		vertex_positions_;			// vertex position Array1D
	Array1D<TV>		vertex_positions_temp_;		// temp for smoothing
	Array1D<TV>		vertex_normals_;
	Array1D<TV>		vertex_mean_curvatures_;	// 
	Array1D<TV>		vertex_rgb_;
	Array1D<TV2>	vertex_uv_;	

	Array1D<TV_INT> uv_triangles_;
	Array1D<TV_INT>	triangles_;					// index of 3 vertices

	BOX_3D<T>		OOBB_;						// object oriented bounding box

	Array1D<TV>		vertex_positions_backup_;	// for undo
	Array1D<TV_INT>	triangles_backup_;			// for undo

	// vertex-triangles connectivity
	Array1D<int> start_ix_adj_tri_of_vertices_;		// 1. count number of adjacent neighbors, 2. store index of neighboring triangles index
	Array1D<int> adj_tri_ix_of_vertices_;				// stores the indices of connected triangles	//TODO: atomic

	Array1D<TV_INT> edge_tri_ix_of_triangles_;		// adjacent triangles of triangles
	Array1D<TV_INT> edge_v_ix_of_triangles_;			// edge vertex generated by subdivision

	LinkedArray<TV> new_vertex_postitions_;		// subdivision vertex buffer
	LinkedArray<TV_INT> new_triangles_;

	Array1D<int>		triangles_flag_;	// -1: do not remove this time, -2: deleted
	Array1D<int>		vertices_flag_;		// -1: deleted

	VERTEX_OPERATIONS	v_ops_;
	StaticTriangleOperations tri_ops_;

	bool use_face_normal_;

public:
	StaticTriangularSurface()
		: v_ops_(vertex_positions_, vertex_normals_, start_ix_adj_tri_of_vertices_), tri_ops_(vertex_positions_, triangles_, edge_tri_ix_of_triangles_), use_face_normal_(false)
	{}

public:
	TV   getEdgeVertex(const int mode, const int& tri_ix, const int& edge_number) const;
	BOX_3D<T> getAABB() const;

	void removeEdge(const int& tri_ix0, const int& tri_ix1, const int& edge_ix0, const int& edge_ix1, const int& v_ix0, const int& v_ix1);
	int  removeShortEdges(const T& min_edge_length, const T kappa);

	void findAdjacentTrianglesOfVertices();
	void determineFaceAveragedVertexNormals();
	void determineVertexMeanCurvatures();
	void findEdgeTrianglesOfTriangles();
	void findBoundaryEdges(LinkedArray<TV2_INT>& boundary_edges);

	void advanceOneSubdivisionStep(const int mode);
	void applySubdivision(const int mode);	// 0: linear, 1: butterfly, 2: loop
	void applyPlaneCutSuvdivision(const PLANE& cut_plane);
	void applyLaplacianSmoothing();
	void generateEdgeVerticesPlaneCut(const PLANE& cut_plane);
	void generateEdgeVertices(const int mode);
	void splitTriangles();
	void updateVertexAndTriangleLists();
	void smoothVertexPositionsLoop();
	void smoothVertexPositionsLaplacian();
	void replaceVertex(const int& tri_ix, const int& old_v, const int& new_v);	// replace old_v with new_v if tri_ix has old_v
	void emptifyTriangle(const int& tri_ix);
	void replaceAdjTriangle(const int& v_ix, const int& old_tri_ix, const int& new_tri_ix);
	void replaceAdjTriangle(const int& v_ix, const int& old_tri_ix1, const int& old_tri_ix2, const int& new_tri_ix);
	void replaceVertexOfAdjTriangles(const int& v_ix, const int& old_v_ix, const int& new_v_ix);
	void replaceEdgeTriangle(const int& tri_ix, const int& old_tri_ix, const int& new_tri_ix);
	void tagAdjTriangles(const int& v_ix, const int& tri_flag, const int recursive_count);
	bool containInvalidAdjTriangles(const int& v_ix);
	void removeEdgeSharingTriangles(const int &tri_ix0, const int & tri_ix1, const int& edge_ix0, const int& edge_ix1);
	void getTriangle(const int& tri_ix, StaticTriangle& triangle) const;
	void getTriangleUV(const int& tri_ix, TV2 uv_arr[3])const;

	void copyRenderingData(Array1D<TV>& positions, Array1D<TV>& normals) const;
	void copyRenderingData(LinkedArray<TV>& positions, LinkedArray<TV>& normals) const;
	void copyRenderingDataShortEdges(LinkedArray<TV>& positions, const T min_edge_length) const;
	void copyRenderingDataShortEdgeTriangles(LinkedArray<TV>& positions, LinkedArray<TV>& normals, const T min_edge_length, const T normal_offset) const;
	void copyRenderingDataHighCurvatureVertices(LinkedArray<TV>& positions, LinkedArray<TV>& normals, const T min_edge_length, const T normal_offset) const;

	// file reading will be moved to other classes
// 	void ReadTRI(const char *filename);			// custom format in which triangle indexes are 0 based unlikely to SMF format.
// 	void ReadSMF(const char *filename);
// 	void ReadOBJ(const char *filename);

	void writeOBJ(const char* filename);
	void writeSTL(const char* filename);
	void writeCTM(const char* filename);
	void writeFile(const char* filename);	// custom '.trisurface' format
	void readFile(const char* filename);

	void backup();
	void restore();

	bool checkEdgeConnectivity();
	bool checkAllTrianglesContainVIX(const int&v_ix);

	// transformation
	void translate(const TV& dev)
	{
		const int num = vertex_positions_.num_elements_;

		for (int i = 0; i < num; i++)
		{
			vertex_positions_.values_[i] += dev;
		}
	}
};
