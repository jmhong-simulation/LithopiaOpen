// The Lithopia project initiated by Jeong-Mo Hong for 3D Printing Community.
// Copyright (c) 2015 Jeong-Mo Hong - All Rights Reserved. 
// This file is subject to the terms and conditions defined in 
// file 'LICENSE.txt', which is part of this source code package.
#include "DynamicVertex.h"
#include "DynamicTriangle.h"
#include "MarchingCubesAlgorithm.h"
#include "MarchingCubesAlgorithmTables.h"

void MarchingCubesAlgorithm::generateTriangles(MT* mt, const int thread_id, const Array3D<T>& node_phi_array_, StaticTriangularSurface &surface_)
{
	int tri_count = 0;

	LinkedArray<TV_INT> triangles_buffer;

	BEGIN_BOX_ITERATION_ARR_3D_SYNC(cell_grid_)
	{
		T phi[8];
		bool is_skip = false;

		// sample 8 node values at corners of a cube
		for (int node = 0; node < 8; node++)
		{
			const TV_INT nl(((int)node_lookup[node][0] + 1) / 2 + i, ((int)node_lookup[node][1] + 1) / 2 + j, ((int)node_lookup[node][2] + 1) / 2 + k);	// TODO: redefine node_lookup

			phi[node] = node_phi_array_(nl);

			//phi[node] -= iso_level_;

			if (phi[node] == (T)0) phi[node] = -(T)1e-8;		// to avoid making zero area triangles

// 			if (phi[node] >= quater_dx_)
// 			{
// 				is_skip = true;
// 				break;
// 			}
		}

		if (is_skip == true)	continue;

		// find cube index
		int cube_index(0);
		if (phi[0] <= (T)0) cube_index |= 1;
		if (phi[1] <= (T)0) cube_index |= 2;
		if (phi[2] <= (T)0) cube_index |= 4;
		if (phi[3] <= (T)0) cube_index |= 8;
		if (phi[4] <= (T)0) cube_index |= 16;
		if (phi[5] <= (T)0) cube_index |= 32;
		if (phi[6] <= (T)0) cube_index |= 64;
		if (phi[7] <= (T)0) cube_index |= 128;

		if (MCTABLES::EdgeTable[cube_index] == 0) continue;

		int edge_vertex[12];

		edge_vertex[0] = x_edge_vertices_(i, j + 1, k);
		edge_vertex[1] = y_edge_vertices_(i + 1, j, k);
		edge_vertex[2] = x_edge_vertices_(i, j, k);
		edge_vertex[3] = y_edge_vertices_(i, j, k);
		edge_vertex[4] = x_edge_vertices_(i, j + 1, k + 1);
		edge_vertex[5] = y_edge_vertices_(i + 1, j, k + 1);
		edge_vertex[6] = x_edge_vertices_(i, j, k + 1);
		edge_vertex[7] = y_edge_vertices_(i, j, k + 1);
		edge_vertex[8] = z_edge_vertices_(i, j + 1, k);
		edge_vertex[9] = z_edge_vertices_(i + 1, j + 1, k);
		edge_vertex[10] = z_edge_vertices_(i + 1, j, k);
		edge_vertex[11] = z_edge_vertices_(i, j, k);

/*
		// make vertices
		for (int edge = 0; edge < 12; edge++)
		{
			if (GetEdgeVertex(thread_id, edge, i, j) != 0) continue;		// if vertex on this edge was generated by other cubes, don't need to generate it again

			if (MCTABLES::EdgeTable[cube_index] & power_of_two[edge])
			{
				// node indexes of this edge
				const int n0 = Nodes_of_Edges[edge][0];
				const int n1 = Nodes_of_Edges[edge][1];

				// phi values of edge nodes
				T phi0 = phi[Nodes_of_Edges[edge][0]];
				T phi1 = phi[Nodes_of_Edges[edge][1]];

				if (phi0 == (T)0) phi0 = -(T)1e-8;		// to avoid making zero area triangles
				if (phi1 == (T)0) phi1 = -(T)1e-8;

				TV3 vertex_position = (ABS(phi1)*NodePosition(thread_id, n0, i, j, k) + ABS(phi0)*NodePosition(thread_id, n1, i, j, k)) / (ABS(phi1) + ABS(phi0));

				//						TV3 vertex_normal = levelset->GetNormalS(vertex_position);
				TV3 vertex_normal = TV(0, 0, 1);	//temporary

				//NOTE:T additional vertex properties can be interpolated here.
				//		V velocity = levelset.interpolateVelocity(p);

				DynamicVertex *vertex = new DynamicVertex(vertex_position.values_, vertex_normal.values_);
				//NOTE: additional vertex properties can be assigned here.

				SetEdgeVertex(thread_id, edge, i, j, vertex);

				surfaces_[thread_id]->AddVertex(vertex);
			}
		}
*/

		for (int l = 0; l < 5; l++)
			if (MCTABLES::TriTable[cube_index][l * 3 + 0] != -1)
			{
				triangles_buffer.PushBack() = TV_INT(edge_vertex[MCTABLES::TriTable[cube_index][l * 3 + 0]], edge_vertex[MCTABLES::TriTable[cube_index][l * 3 + 1]], edge_vertex[MCTABLES::TriTable[cube_index][l * 3 + 2]]);
				tri_count++;

// 				surfaces_[thread_id]->AddTriangle(GetEdgeVertex(thread_id, MCTABLES::TriTable[cube_index][l * 3 + 0], i, j),
// 					GetEdgeVertex(thread_id, MCTABLES::TriTable[cube_index][l * 3 + 1], i, j),
// 					GetEdgeVertex(thread_id, MCTABLES::TriTable[cube_index][l * 3 + 2], i, j));
			}
	}
	END_GRID_ITERATION_Z_SYNC;

	// merge triangle buffer
	// copy vertex buffer to a full array
	const int num_all_triangles = mt->syncSum(thread_id, tri_count);
	BEGIN_ONE_THREAD_WORK
	{
		surface_.triangles_.initialize(num_all_triangles);		
	}
	END_ONE_THREAD_WORK;

	const Vector2D<int> tri_ix_range = mt->getIncrementalRange(thread_id, tri_count);
	triangles_buffer.CopyToPartialArray(surface_.triangles_, tri_ix_range.t_min_);
}

void MarchingCubesAlgorithm::generateVertices(MT* mt, const int thread_id, const GridUniform3D& node_grid, const Array3D<T>& node_phi_array_, StaticTriangularSurface &surface_)
{
	int num_vertices = 0;		// number of vertices generated by this thread
	LinkedArray<TV> vertex_buffer, normal_buffer;

	generateEdgeVertices(mt, thread_id, node_grid, x_edge_grid_, node_phi_array_, TV_INT(1, 0, 0), num_vertices, vertex_buffer, normal_buffer, x_edge_vertices_);
	generateEdgeVertices(mt, thread_id, node_grid, y_edge_grid_, node_phi_array_, TV_INT(0, 1, 0), num_vertices, vertex_buffer, normal_buffer, y_edge_vertices_);
	generateEdgeVertices(mt, thread_id, node_grid, z_edge_grid_, node_phi_array_, TV_INT(0, 0, 1), num_vertices, vertex_buffer, normal_buffer, z_edge_vertices_);

	const Vector2D<int> vix_range = mt->getIncrementalRange(thread_id, num_vertices);

	// correct local vertex ix
	BEGIN_BOX_ITERATION_ARR_3D_SYNC(x_edge_grid_)
	{
		if (x_edge_vertices_(i, j, k) != -1) x_edge_vertices_(i, j, k) += vix_range.t_min_;
	}
	END_GRID_ITERATION_Z_SYNC;//TODO: no need for z sync

	BEGIN_BOX_ITERATION_ARR_3D_SYNC(y_edge_grid_)
	{
		if (y_edge_vertices_(i, j, k) != -1) y_edge_vertices_(i, j, k) += vix_range.t_min_;
	}
	END_GRID_ITERATION_Z_SYNC;//TODO: no need for z sync

	BEGIN_BOX_ITERATION_ARR_3D_SYNC(z_edge_grid_)
	{
		if (z_edge_vertices_(i, j, k) != -1) z_edge_vertices_(i, j, k) += vix_range.t_min_;
	}
	END_GRID_ITERATION_Z_SYNC;//TODO: no need for z sync

	// copy vertex buffer to a full array
	const int num_all_vertices = mt->syncSum(thread_id, num_vertices);
	BEGIN_ONE_THREAD_WORK
	{
		surface_.vertex_positions_.initialize(num_all_vertices);
		surface_.vertex_normals_.initialize(num_all_vertices);
	}
	END_ONE_THREAD_WORK;

	vertex_buffer.CopyToPartialArray(surface_.vertex_positions_, vix_range.t_min_);
	normal_buffer.CopyToPartialArray(surface_.vertex_normals_, vix_range.t_min_);
}

void MarchingCubesAlgorithm::polygonize(MT* mt, const int thread_id, const GridUniform3D& node_grid, const Array3D<T>& node_phi_array_, StaticTriangularSurface& surface_)
{
	// initialize
	BEGIN_ONE_THREAD_WORK
	{
		cell_grid_ = node_grid.getCellGrid();		// these cells are marching cubes.

		// obtain edge grids from cell grid
		x_edge_grid_ = cell_grid_.getXEdgeGrid();
		y_edge_grid_ = cell_grid_.getYEdgeGrid();
		z_edge_grid_ = cell_grid_.getZEdgeGrid();

		x_edge_grid_.initializeCenterArray(x_edge_vertices_);
		y_edge_grid_.initializeCenterArray(y_edge_vertices_);
		z_edge_grid_.initializeCenterArray(z_edge_vertices_);
	}
	END_ONE_THREAD_WORK;

	generateVertices(mt, thread_id, node_grid, node_phi_array_, surface_);

	generateTriangles(mt, thread_id, node_phi_array_, surface_);

	// emptify memory
	BEGIN_ONE_THREAD_WORK
	{
		x_edge_vertices_.reset();
		y_edge_vertices_.reset();
		z_edge_vertices_.reset();
	}
	END_ONE_THREAD_WORK;
}

bool MarchingCubesAlgorithm::isIntersecting(const T phi0, const T phi1)
{
	if (phi0 <= (T)0 && phi1 > (T)0) return true;
	else if (phi1 <= (T)0 && phi0 > (T)0) return true;
	else return false;
}

void MarchingCubesAlgorithm::generateEdgeVertices(MT* mt, const int thread_id, const GridUniform3D& node_grid, const GridUniform3D& u_grid_, const Array3D<T>& node_phi_array_, const TV_INT ix_dev, int& num_vertices, LinkedArray<TV>& vertex_buffer, LinkedArray<TV>& normal_buffer, Array3D<int>& u_vertices_)
{
	// TODO: work on one z plane with all threads for better performance
	BEGIN_BOX_ITERATION_ARR_3D_SYNC(u_grid_)
	{
		const T phi0 = node_phi_array_(i, j, k);
		const T phi1 = node_phi_array_(TV_INT(i, j, k) + ix_dev);

		if (isIntersecting(phi0, phi1) == true)
		{
			const T theta = ABS(phi1) / (ABS(phi0) + ABS(phi1));

			vertex_buffer.PushBack() = node_grid.getCellCenter(i, j, k) * theta + node_grid.getCellCenter(TV_INT(i, j, k) + ix_dev) * ((T)1 - theta);

			const TV estimated_normal = (phi1 > phi0) ? TV((T)ix_dev.x_, (T)ix_dev.y_, (T)ix_dev.z_) : TV(-(T)ix_dev.x_, -(T)ix_dev.y_, -(T)ix_dev.z_);		//TODO: use level set normal

			normal_buffer.PushBack() = estimated_normal;

			u_vertices_(i, j, k) = num_vertices++;
		}
		else u_vertices_(i, j, k) = -1;
	}
	END_GRID_ITERATION_Z_SYNC;	//TODO: no need for z sync
}

/*
void MarchingCubesAlgorithm::initialize(MT* mt, GridUniform3D& grid, T grid_scale, const T x_dev_input, const T y_dev_input, const T z_dev_input)
{
	int i_start, j_start, k_start;
	int i_end, j_end, k_end;

	i_start = grid.i_start_; j_start = grid.j_start_; k_start = grid.k_start_;
	i_end = grid.i_end_; j_end = grid.j_end_; k_end = grid.k_end_;

	int i_res = i_end-i_start+1;
	int j_res = j_end-j_start+1;
	int k_res = k_end-k_start+1;

	resolution_x_ = i_res*(int)grid_scale;
	resolution_y_ = j_res*(int)grid_scale;
	resolution_z_ = k_res*(int)grid_scale;

	num_thread_ = MIN2(resolution_z_, (int)mt->num_threads_);

	if(surfaces_.num_elements_ != 0) 
		for(int i=0;i<surfaces_.num_elements_;i++)
			SAFE_DELETE(surfaces_[i]);

	surfaces_.initialize(num_thread_,0);

	vertex_start_indexs.initialize(num_thread_);
	vertex_end_indexs.initialize(num_thread_);
	triangle_start_indexs.initialize(num_thread_);
	triangle_end_indexs.initialize(num_thread_);

	x_edge_vertices_.initialize(num_thread_,0);
	y_edge_vertices_.initialize(num_thread_,0);
	z_edge_vertices_.initialize(num_thread_,0);
	x_edge_vertices_k0_.initialize(num_thread_,0); 
	y_edge_vertices_k0_.initialize(num_thread_,0);

//	ARRAY<GRID_UNIFORM_3D> partial_grids;		
//	grid.SplitInZDirection(num_thread_, partial_grids);

	dx_ = (T)1/grid_scale;
	dy_ = (T)1/grid_scale;
	dz_ = (T)1/grid_scale;

	half_dx_ = dx_*(T)0.5;
	half_dy_ = dy_*(T)0.5;
	half_dz_ = dz_*(T)0.5;

	quater_dx_ = MAX3(dx_,dy_,dz_)*(T)4;

	min_sizes_.initialize(num_thread_);
	max_sizes_.initialize(num_thread_);
	resolutions_z_.initialize(num_thread_);

	mt->splitRange(k_start, k_start + k_res - 1);

	for(int i = 0;i < num_thread_; i++)
	{
		resolutions_z_[i] = (mt->end_ix_1D_[i] - mt->start_ix_1D_[i]) + 1;

		min_sizes_[i].x_ = (T)i_start;
		max_sizes_[i].x_ = (T)i_end + (T)1;

		min_sizes_[i].y_ = (T)j_start;
		max_sizes_[i].y_ = (T)j_end + (T)1;

		min_sizes_[i].z_ = (T)mt->start_ix_1D_[i];
		max_sizes_[i].z_ = (T)mt->end_ix_1D_[i] + (T)1;

		surfaces_[i] = new DynamicTriangularSurface();
	}

	deviation_.x_ = x_dev_input;
	deviation_.y_ = y_dev_input;
	deviation_.z_ = z_dev_input;

	global_translation_ = TV3();

	iso_level_ = 0.0f;
}

void MarchingCubesAlgorithm::PolygonizeThread(MT* mt, const int thread_id, const GridUniform3D& grid, Array3D<T>* levelset)
{
// 	if(ghost_wall_ == true)
// 	{
// 		levelset->domain_.AssignGhostValues(thread_id, levelset->phi_arr_, (T)0.7);
// 		levelset->ComputeNormals(thread_id, true);
// 	}

	DynamicVertex **x_edge_vertices_old_, **x_edge_vertices_temp_;
	DynamicVertex **y_edge_vertices_old_, **y_edge_vertices_temp_;

	surfaces_[thread_id]->Reset();

	SAFE_DELETE_ARRAY(x_edge_vertices_[thread_id]);
	SAFE_DELETE_ARRAY(y_edge_vertices_[thread_id]);

	int num_01 = resolution_x_*(resolution_y_+1);
	int num_02 = (resolution_x_+1)*resolution_y_;
	int num_03 = resolution_x_*(resolution_y_+1)*2;
	int num_04 = (resolution_x_+1)*resolution_y_*2;
	int num_05 = (resolution_x_+1)*(resolution_y_+1);

	x_edge_vertices_[thread_id] = new DynamicVertex* [num_03];
	y_edge_vertices_[thread_id] = new DynamicVertex* [num_04];
	z_edge_vertices_[thread_id] = new DynamicVertex* [num_05];	

	x_edge_vertices_old_ = new DynamicVertex* [num_03];
	y_edge_vertices_old_ = new DynamicVertex* [num_04];
		
	x_edge_vertices_k0_[thread_id] = new DynamicVertex* [num_01];
	y_edge_vertices_k0_[thread_id] = new DynamicVertex* [num_02];

	for(int i=0; i < num_01; i++)	x_edge_vertices_k0_[thread_id][i]=0;
	for(int i=0; i < num_02; i++)	y_edge_vertices_k0_[thread_id][i]=0;

	for(int i=0;i<num_03;i++)   x_edge_vertices_old_[i] = 0;
	for(int i=0;i<num_04;i++)	y_edge_vertices_old_[i] = 0;

	for(int k = 0; k < resolutions_z_[thread_id]; k++)
	{
		//LOG::cout<<"Marching z direction "<<k<<std::endl;

		for(int i=0; i < num_03; i++)	x_edge_vertices_[thread_id][i]=0;
		for(int i=0; i < num_04; i++)	y_edge_vertices_[thread_id][i]=0;
		for(int i=0; i < num_05; i++)	z_edge_vertices_[thread_id][i]=0;

		for(int i=0; i < resolution_x_; i++)
			for(int j=0; j < (resolution_y_+1); j++)
				x_edge_vertices_[thread_id][index_edge_x(i,j,0)] = x_edge_vertices_old_[index_edge_x(i,j,1)];

		for(int i=0; i < (resolution_x_+1); i++)
			for(int j=0; j < resolution_y_; j++)
				y_edge_vertices_[thread_id][index_edge_y(i,j,0)] = y_edge_vertices_old_[index_edge_y(i,j,1)];
		
		// set thread boundary edge
		if(resolutions_z_[thread_id]-1 == k)
		{
			mt->sync();

			if(thread_id!=num_thread_-1)
			for(int i = 0; i < resolution_x_ ; i++)
				for(int j = 0; j < resolution_y_; j++)
				{
					x_edge_vertices_[thread_id][index_edge_x(i,j,1)] = x_edge_vertices_k0_[thread_id+1][index_edge_x(i,j,0)];
					y_edge_vertices_[thread_id][index_edge_y(i,j,1)] = y_edge_vertices_k0_[thread_id+1][index_edge_y(i,j,0)];
				}
		}

		for(int j = 0; j < resolution_y_; j++)
			for(int i = 0; i < resolution_x_; i++)
			{
				T phi[8];
				bool is_skip = false;

				// sample 8 node values at corners of a cube
				for(int node = 0; node < 8; node++)
				{
					phi[node] = interpolateTrilinear(grid, *levelset, NodePosition(thread_id,node,i,j,k));

					phi[node] -= iso_level_;

					if(phi[node] == (T)0) phi[node] = -(T)1e-8;		// to avoid making zero area triangles

					if(phi[node] >= quater_dx_)
					{
						is_skip = true; 
						break;
					}
				}

				if(is_skip == true)	continue;

				// find cube index

				int cube_index(0);
				if (phi[0] <= (T)0) cube_index |= 1; 
				if (phi[1] <= (T)0) cube_index |= 2;
				if (phi[2] <= (T)0) cube_index |= 4;
				if (phi[3] <= (T)0) cube_index |= 8;
				if (phi[4] <= (T)0) cube_index |= 16;
				if (phi[5] <= (T)0) cube_index |= 32;
				if (phi[6] <= (T)0) cube_index |= 64;
				if (phi[7] <= (T)0) cube_index |= 128;

				if (MCTABLES::EdgeTable[cube_index] == 0) continue;
				
				// make vertices
				for(int edge = 0; edge < 12; edge++)
				{
					if(GetEdgeVertex(thread_id,edge, i, j) != 0) continue;		// if vertex on this edge was generated by other cubes, don't need to generate it again

					if(MCTABLES::EdgeTable[cube_index] & power_of_two[edge])
					{
						// node indexes of this edge
						const int n0 = Nodes_of_Edges[edge][0];
						const int n1 = Nodes_of_Edges[edge][1];

						// phi values of edge nodes
						const T phi0 = phi[Nodes_of_Edges[edge][0]];
						const T phi1 = phi[Nodes_of_Edges[edge][1]];

						TV3 vertex_position = (ABS(phi1)*NodePosition(thread_id,n0,i,j,k) + ABS(phi0)*NodePosition(thread_id,n1,i,j,k))/(ABS(phi1)+ABS(phi0));

//						TV3 vertex_normal = levelset->GetNormalS(vertex_position);
						TV3 vertex_normal = TV(0, 0, 1);	//temporary

						//NOTE:T additional vertex properties can be interpolated here.
						//		V velocity = levelset.interpolateVelocity(p);

						DynamicVertex *vertex = new DynamicVertex(vertex_position.values_, vertex_normal.values_);
						//NOTE: additional vertex properties can be assigned here.

						SetEdgeVertex(thread_id,edge,i,j,vertex);

						surfaces_[thread_id]->AddVertex(vertex);
					}
				}	
				
				for(int l = 0; l < 5; l++)
					if(MCTABLES::TriTable[cube_index][l*3+0] != -1)
						surfaces_[thread_id]->AddTriangle(GetEdgeVertex(thread_id,MCTABLES::TriTable[cube_index][l*3+0], i, j),
						GetEdgeVertex(thread_id,MCTABLES::TriTable[cube_index][l*3+1], i, j),
						GetEdgeVertex(thread_id,MCTABLES::TriTable[cube_index][l*3+2], i, j));
			}//End of resolution_x, resolution_y loop
			
			if(k==0)
			{
				for(int i=0; i < resolution_x_; i++)
					for(int j=0; j < (resolution_y_+1); j++)
						x_edge_vertices_k0_[thread_id][index_edge_x(i,j,0)] = x_edge_vertices_[thread_id][index_edge_x(i,j,0)];

				for(int i=0; i < (resolution_x_+1); i++)
					for(int j=0; j < resolution_y_; j++)
						y_edge_vertices_k0_[thread_id][index_edge_y(i,j,0)] = y_edge_vertices_[thread_id][index_edge_y(i,j,0)];
			}

			x_edge_vertices_temp_ = x_edge_vertices_old_;
			x_edge_vertices_old_ = x_edge_vertices_[thread_id];
			x_edge_vertices_[thread_id] = x_edge_vertices_temp_;
			x_edge_vertices_temp_ = 0;

			y_edge_vertices_temp_ = y_edge_vertices_old_;
			y_edge_vertices_old_ = y_edge_vertices_[thread_id];
			y_edge_vertices_[thread_id] = y_edge_vertices_temp_;
			y_edge_vertices_temp_ = 0;

	}// End of resolution_z loop
	
	mt->sync();

	for(int i=0;i<num_thread_;i++)
	{
		vertex_start_indexs[thread_id]   = 0;
		vertex_end_indexs[thread_id]     = 0;
		triangle_start_indexs[thread_id] = 0;
		triangle_end_indexs[thread_id]   = 0;
	}

	for(int i=0;i<thread_id;i++)
	{
		vertex_start_indexs[thread_id] += (int)surfaces_[i]->vertices_.size();
		triangle_start_indexs[thread_id] += (int)surfaces_[i]->triangles_.size();
	}

	for(int i=0;i<=thread_id;i++)
	{
		vertex_end_indexs[thread_id] += (int)surfaces_[i]->vertices_.size();
		triangle_end_indexs[thread_id] += (int)surfaces_[i]->triangles_.size();
	}

	mt->sync();

	if(thread_id == 0)
	{
		vertices_.initialize(vertex_end_indexs[num_thread_-1]);
		triangles_.initialize(triangle_end_indexs[num_thread_-1]);

		// multithreading_->SplitDomainIndex1D(0, triangle_end_indexs[num_thread_-1]);
		const int k_start = 0;
		const int k_res = triangle_end_indexs[num_thread_-1];
		const int k_end = k_start + k_res - 1;
		const int quotient = k_res/num_thread_;
		const int remainder = k_res%num_thread_;

		int k_start_p = k_start;

		for(int i = 0; i < num_thread_; i++)
		{
			int k_depth = i < remainder ? (quotient + 1) : quotient;

			mt->start_ix_1D_[i] = k_start_p;
			mt->end_ix_1D_[i] = k_start_p + k_depth - 1;

			k_start_p += k_depth;
		}
	}
	mt->sync();

	std::list <DynamicTriangle*>::iterator itr_triangle;
	itr_triangle = surfaces_[thread_id]->triangles_.begin(); 
	for(int i=triangle_start_indexs[thread_id];i<triangle_end_indexs[thread_id];i++)
	{
		triangles_[i] = (*itr_triangle);
		itr_triangle++;
	}
	mt->sync();

	int counter = 0;
	for(int i = vertex_start_indexs[thread_id]; i < vertex_end_indexs[thread_id]; i++)
	{
		vertices_[i] = surfaces_[thread_id]->vertices_[counter];
		surfaces_[thread_id]->vertices_[counter]->index_ = i+1;
		counter++;
	}
	mt->sync();

	BEGIN_1D_ITERATION(triangles_.num_elements_)
	{
		triangles_[p]->CorrectCCW();
		triangles_[p]->DetermineNormal();
	}
	END_1D_ITERATION;	
	
	if(thread_id == 0)
	{
		//	multithreading_->SplitDomainIndex1D(0, vertex_end_indexs[num_thread_-1]);
		const int k_start = 0;
		const int k_res = vertex_end_indexs[num_thread_-1];
		const int k_end = k_start + k_res - 1;
		const int quotient = k_res/num_thread_;
		const int remainder = k_res%num_thread_;

		int k_start_p = k_start;

		for(int i = 0; i < num_thread_; i++)
		{
			int k_depth = i < remainder ? (quotient + 1) : quotient;

			mt->start_ix_1D_[i] = k_start_p;
			mt->end_ix_1D_[i] = k_start_p + k_depth - 1;

			k_start_p += k_depth;
		}
	}
	mt->sync();

	BEGIN_1D_ITERATION(vertices_.num_elements_)
	{
		vertices_[p]->DetermineNormal();
	}
	END_1D_ITERATION;

	SAFE_DELETE_ARRAY(x_edge_vertices_[thread_id]);
	SAFE_DELETE_ARRAY(y_edge_vertices_[thread_id]);
	SAFE_DELETE_ARRAY(z_edge_vertices_[thread_id]);
	SAFE_DELETE_ARRAY(x_edge_vertices_old_);
	SAFE_DELETE_ARRAY(y_edge_vertices_old_);
	SAFE_DELETE_ARRAY(x_edge_vertices_k0_[thread_id]);
	SAFE_DELETE_ARRAY(y_edge_vertices_k0_[thread_id]);

//	AverageNormals(thread_id, 3);
}


void MarchingCubesAlgorithm::AverageNormals(MT* mt, const int thread_id, const int itr)
{
	for(int i = 0; i < itr; ++i)
	{
		BEGIN_1D_ITERATION(vertices_.num_elements_)
		{
			vertices_[p]->DetermineAverageNormal();
		}
		END_1D_ITERATION;

		BEGIN_1D_ITERATION(triangles_.num_elements_)
		{
			triangles_[p]->DetermineAverageNormal();
		}
		END_1D_ITERATION;
	}
}
*/

/*
void MarchingCubesAlgorithm::PolygonizeUseFillGhostCellsFromThread(int& thread_id, LEVELSET_UNIFORM_3D* levelset)
{
//	levelset->FillGhostCellsFrom(thread_id, levelset->phi_, false);
}
*/

/*
void MarchingCubesAlgorithm::Polygonize(LEVELSET_UNIFORM_3D& levelset, bool use_fill_ghost_cells_from)
{
	if(use_fill_ghost_cells_from==true)
		GET_MULTITHREADING->RunThreads(num_thread_, &MarchingCubesAlgorithm::PolygonizeUseFillGhostCellsFromThread, this, &levelset);

	GET_MULTITHREADING->RunThreads(num_thread_, &MarchingCubesAlgorithm::PolygonizeThread, this, &levelset);
}//End of Polygonize_Levelset_Implicit_Object
*/

/*
void MarchingCubesAlgorithm::Polygonize(MT* mt, const GridUniform3D& grid, Array3D<T>* levelset)
{
	mt->runWithID(&MarchingCubesAlgorithm::PolygonizeThread, this, grid, levelset);
	mt->joinAll();
}
*/

/*
void MarchingCubesAlgorithm::Polygonize(LEVELSET_UNIFORM_3D& levelset)
{
	GET_MULTITHREADING->RunThreads(num_thread_, &MarchingCubesAlgorithm::PolygonizeThread, this, &levelset);
}//End of Polygonize_Levelset_Implicit_Object
*/

/*
bool MarchingCubesAlgorithm::IsInterfacial(const T phi[8])
{
	// check if this 8 phi values are interfacial
	if(phi[0]>(T)0)
	{
		for(int i = 1; i < 8; i ++)
			if(phi[i]<=(T)0) return true;
	}
	else
	{
		for(int i = 1; i < 8; i++)
			if(phi[i] > (T)0) return true;
	}

	return false;
}
*/
